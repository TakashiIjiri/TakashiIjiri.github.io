<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>手動フーリエ（cos 基底・矩形波ターゲット）</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif; margin: 0; background: #f6f7fb; color: #111827; }
    .container { max-width: 1180px; margin: 36px auto; padding: 24px; background: #fff; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.08); }
    h1 { font-size: 22px; margin: 0 0 8px; }
    p.lead { margin: 0 0 18px; color: #6b7280; font-size: 14px; }

    .grid { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 18px; }
    @media (min-width: 1100px){ .grid { grid-template-columns: repeat(3, minmax(0,1fr)); } }

    .panel { background: linear-gradient(#fcfdff, #f7f9ff); border-radius: 14px; padding: 14px; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
    .title { display:flex; align-items: baseline; gap:10px; margin-bottom: 8px; }
    .title .badge { font-size: 12px; font-weight: 700; padding: 2px 8px; border-radius: 999px; }

    .controls { display: grid; grid-template-columns: 1fr; gap: 10px; margin: 6px 0 4px; }
    label { font-size: 13px; font-weight: 600; display: flex; justify-content: space-between; gap: 8px; }
    .value { font-variant-numeric: tabular-nums; font-weight: 700; }
    input[type="range"] { width: 100%; accent-color: currentColor; }
    .equation { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", "Courier New", monospace; background: #eef2ff; border-radius: 8px; padding: 6px 8px; display:inline-block; }
    .hint { color:#6b7280; font-size:12px; margin-left: 8px; }

    svg { width: 100%; height: 260px; margin-top: 8px; border-radius: 10px; }
    .gridlines line { stroke: #e5e7eb; stroke-width: 1; }
    .axis { stroke: #9ca3af; stroke-width: 1.5; }

    .c0 { color:#111827; }
    .c1 { color:#2563eb; }
    .c2 { color:#16a34a; }
    .c3 { color:#ef4444; }
    .c4 { color:#a855f7; }
    .c5 { color:#f59e0b; }

    .curve { fill:none; stroke: currentColor; stroke-width: 3; }
    .target { fill:none; stroke:#1d4ed8; stroke-width:3; stroke-dasharray:0; }

    .sum { grid-column: 1 / -1; }
    .sum .equation { background:#f2f4f8; }
    .sum .curve { stroke:#111827; }
    .sum small { color:#6b7280; }

    .toolbar { display:flex; gap:8px; align-items:center; margin: 6px 0 0; }
    .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .btn:hover{ background:#f9fafb; }
  </style>
</head>
<body>
  <div class="container">
    <h1>manual Fourie transform 手動フーリエ変換</h1>
    <p class="lead">
    青い関数がターゲットです。下のcos関数の振幅・位相ずれを調整して、合成結果がなるべく青い関数になるようにしてください。<br>
    ※秋学期の講義 ディジタルメディア処理 用のサイトです。
    </p>

    <!-- 合成＋ターゲット -->
    <div class="panel sum">
      <div class="title"><span class="badge">合成＆ターゲット</span> <span class="equation" id="eqSum"></span> <small class="hint">（縦スケール固定 / クリップあり）</small></div>
      <svg viewBox="0 0 1000 320" aria-label="sum">
        <g class="gridlines">
          <line x1="0" y1="64" x2="1000" y2="64"/>
          <line x1="0" y1="160" x2="1000" y2="160" class="axis"/>
          <line x1="0" y1="256" x2="1000" y2="256"/>
          <line x1="0" y1="0" x2="0" y2="320"/>
          <line x1="250" y1="0" x2="250" y2="320"/>
          <line x1="500" y1="0" x2="500" y2="320"/>
          <line x1="750" y1="0" x2="750" y2="320"/>
          <line x1="1000" y1="0" x2="1000" y2="320"/>
        </g>
        <path class="target" id="curveTarget" d=""/>
        <path class="curve" id="curveSum" d=""/>
      </svg>
      <div class="toolbar">
        <button class="btn" id="btnReset">リセット</button>
        <button class="btn" id="btnShare" title="現在の A,φ を URL に保存">シェア用リンク</button>
      </div>
    </div>

    <!-- 3x2 の基底パネル -->
    <div class="grid" id="grid">
      <!-- JS で 0..5 を展開 -->
    </div>
  </div>

  <template id="tmplPanel">
    <div class="panel">
      <div class="title"><span class="badge"></span><span class="equation"></span><span class="hint"></span></div>
      <div class="controls">
        <div>
          <label>振幅 A <span class="value aVal">0.00</span></label>
          <input class="amp" type="range" min="0" max="1" step="0.01" value="0.1"/>
        </div>
        <div>
          <label>位相 φ [rad] <span class="value pVal">0.00 rad (0°)</span></label>
          <input class="phase" type="range" min="-3.141592653589793" max="3.141592653589793" step="0.001" value="0"/>
        </div>
      </div>
      <svg viewBox="0 0 1000 260" aria-label="basis">
        <g class="gridlines">
          <line x1="0" y1="65" x2="1000" y2="65"/>
          <line x1="0" y1="130" x2="1000" y2="130" class="axis"/>
          <line x1="0" y1="195" x2="1000" y2="195"/>
          <line x1="0" y1="0" x2="0" y2="260"/>
          <line x1="250" y1="0" x2="250" y2="260"/>
          <line x1="500" y1="0" x2="500" y2="260"/>
          <line x1="750" y1="0" x2="750" y2="260"/>
          <line x1="1000" y1="0" x2="1000" y2="260"/>
        </g>
        <path class="curve" d=""/>
      </svg>
    </div>
  </template>

  <script>
    // ===== 固定スケール設定（共通） =====
    const W = 1000, Hbasis = 260, Hsum = 320;     // SVG viewBox
    const axisCenter = 0.5;                        // 中央（0..1）
    const baseScale = 0.40;                        // 固定縦スケール（±1 を画面高さの 0.40 に写像）
    const N = 800;                                 // サンプル点

    // k=0..5 の定義
    const Ks = [0,1,2,3,4,5];

    // URL からロード（a=.., p=..）
    const params = new URLSearchParams(location.hash.slice(1) || location.search.slice(1));
    const initA = (params.get('a') || '').split(',').map(Number);
    const initP = (params.get('p') || '').split(',').map(Number);

    // 既定値（DC=0.5）
    const A = Ks.map(k => (Number.isFinite(initA[k]) ? initA[k] : (k===0? 0.5 : 0.2)));
    const P = Ks.map(k => (Number.isFinite(initP[k]) ? initP[k] : 0));

    // DOM 構築
    const grid = document.getElementById('grid');
    const tmpl = document.getElementById('tmplPanel');

    const panels = Ks.map((k, i) => {
      const node = tmpl.content.cloneNode(true);
      const card = node.querySelector('.panel');
      card.classList.add('c'+k);
      const badge = node.querySelector('.badge');
      badge.textContent = `k = ${k}`;
      const eq = node.querySelector('.equation');
      const hint = node.querySelector('.hint');
      const aVal = node.querySelector('.aVal');
      const pVal = node.querySelector('.pVal');
      const amp = node.querySelector('.amp');
      const phase = node.querySelector('.phase');
      const path = node.querySelector('path.curve');

      amp.value = A[k];
      phase.value = P[k];
      aVal.textContent = A[k].toFixed(2);
      pVal.textContent = `${P[k].toFixed(2)} rad (${(P[k]*180/Math.PI).toFixed(1)}°)`;
      eq.textContent = `y = ${A[k].toFixed(2)} · cos(2π·${k}·x + ${P[k].toFixed(2)})`;

      if (k === 0) {
        // DC 成分：位相は効果なし → UI 上で無効化
        phase.disabled = true;
        hint.textContent = '（DC：φは無効）';
      }

      amp.addEventListener('input', ()=>{ A[k]=parseFloat(amp.value); aVal.textContent=A[k].toFixed(2); eq.textContent = `y = ${A[k].toFixed(2)} · cos(2π·${k}·x + ${P[k].toFixed(2)})`; drawPanel(k, path); drawSum(); });
      phase.addEventListener('input', ()=>{ P[k]=parseFloat(phase.value); pVal.textContent=`${P[k].toFixed(2)} rad (${(P[k]*180/Math.PI).toFixed(1)}°)`; eq.textContent = `y = ${A[k].toFixed(2)} · cos(2π·${k}·x + ${P[k].toFixed(2)})`; drawPanel(k, path); drawSum(); });

      grid.appendChild(node);
      return {k, amp, phase, aVal, pVal, eq, path};
    });

    // ターゲット（矩形波 0/1）
    const targetPath = document.getElementById('curveTarget');
    function drawTarget(){
      const y0 = axisCenter - baseScale * 0;  // 0
      const y1 = axisCenter - baseScale * 1;  // 1
      // x: 0 → 0.25 → 0.75 → 1 の折れ線でステップを描く
      const x0=0, xL=0.15, xR=0.65, x1=1;
      const pts = [
        ['M', x0*W, y0*Hsum],
        ['L', xL*W, y0*Hsum],
        ['L', xL*W, y1*Hsum],
        ['L', xR*W, y1*Hsum],
        ['L', xR*W, y0*Hsum],
        ['L', x1*W, y0*Hsum]
      ];
      targetPath.setAttribute('d', pts.map(p=>`${p[0]}${p[1].toFixed(2)} ${p[2].toFixed(2)}`).join(' '));
    }

    // 単一パネル描画
    function drawPanel(k, pathEl){
      const Ak = A[k];
      const Pk = P[k];
      let d = '';
      for(let i=0;i<=N;i++){
        const x = i/N;
        const yval = (k===0) ? Ak : Ak*Math.cos(2*Math.PI*k*x + Pk);
        const y = axisCenter - baseScale * yval;
        d += (i? 'L':'M') + (x*W).toFixed(2) + ' ' + (y*Hbasis).toFixed(2) + ' ';
      }
      pathEl.setAttribute('d', d.trim());
    }

    // 合成描画（固定スケール）
    const curveSum = document.getElementById('curveSum');
    const eqSum = document.getElementById('eqSum');
    function drawSum(){
      eqSum.textContent = 'y = ' + Ks.map(k=>`${A[k].toFixed(2)}·cos(2π·${k}·x${k===0? '':` + ${P[k].toFixed(2)}`})`).join(' + ');
      let d='';
      for(let i=0;i<=N;i++){
        const x = i/N;
        let yval = 0;
        for(const k of Ks){ yval += (k===0) ? A[k] : A[k]*Math.cos(2*Math.PI*k*x + P[k]); }
        const y = axisCenter - baseScale * yval; // 固定スケール
        d += (i? 'L':'M') + (x*W).toFixed(2) + ' ' + (y*Hsum).toFixed(2) + ' ';
      }
      curveSum.setAttribute('d', d.trim());
    }

    // URL 共有
    function updateURL(){
      const a = Ks.map(k=>A[k].toFixed(3)).join(',');
      const p = Ks.map(k=>P[k].toFixed(3)).join(',');
      const hash = `a=${encodeURIComponent(a)}&p=${encodeURIComponent(p)}`;
      history.replaceState(null, '', `#${hash}`);
    }
    document.getElementById('btnShare').addEventListener('click', ()=>{
      updateURL();
      navigator.clipboard?.writeText(location.href)
        .then(()=>alert('現在の設定を URL に反映し、コピーしました。'))
        .catch(()=>alert('アドレスバーの URL をコピーして共有してください。'));
    });

    // リセット
    document.getElementById('btnReset').addEventListener('click', ()=>{
      Ks.forEach(k=>{ A[k]= (k===0?0.5:0); P[k]=0; });
      panels.forEach(({k,amp,phase,aVal,pVal,eq,path})=>{
        amp.value=A[k]; phase.value=P[k];
        aVal.textContent=A[k].toFixed(2);
        pVal.textContent=`${P[k].toFixed(2)} rad (${(P[k]*180/Math.PI).toFixed(1)}°)`;
        eq.textContent = `y = ${A[k].toFixed(2)} · cos(2π·${k}·x + ${P[k].toFixed(2)})`;
        drawPanel(k, path);
      });
      drawSum(); updateURL();
    });

    // 初期描画
    function initDraw(){
      // 生成済み panels ノードを取得して描画
      const paths = Array.from(document.querySelectorAll('#grid path.curve'));
      Ks.forEach((k, idx)=>{ drawPanel(k, paths[idx]); });
      drawTarget();
      drawSum();
      updateURL();
    }

    // 画面構築直後に一度だけ initDraw（setTimeout で DOM 反映後）
    setTimeout(initDraw, 0);
  </script>
</body>
</html>
